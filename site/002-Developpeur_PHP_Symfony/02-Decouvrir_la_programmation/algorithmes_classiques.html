<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Ce site présente mes notes de cours sur ma formation STUDI de Graduate développeur PHP / Symfony.">
  <link rel="stylesheet" href="../../style.css">
  <title>Graduate développeur PHP/Symfony</title>
</head>
<body>
  <header id="up">
    <h1 class="shape-title">Découvrir la programmation</h1>
  </header>
  <main>
    <section>
      <h2 class="section">Algorithmes classiques</h2>
      <article>
        <p>Pour être un bon développeur, il est important d'avoir une culture des algorithmes classiques. Ce sont des algorithmes qui ont été écrits et qui sont reconnus comme étant la meilleure solution pour un problème donné.</p>
        <nav>
          <section class="return" >
            <h2 class="sub-title-h2">Sommaire</h2>
            <a href="decouvProg.html">Retour</a>
          </section>
          <ul class="li-empty">
            <li><a href="#searchInUnordered">Position d'une valeur (liste non triée)</a></li>
            <li><a href="#maxInUnordered">Maximum d'une valeur (liste non triée)</a></li>
            <li><a href="#maxInOrdered">Maximum d'une valeur (liste triée)</a></li>
            <li><a href="#naive">Algorythme naïf</a></li>
            <li><a href="#dichotomie">Recherche par dichotomie</a></li>
            <li><a href="#cartesien">Créer des paires (produit cartésien)</a></li>
            <li><a href="#fibonacci">Suite de Fibonacci</a></li>
            <li><a href="#triBulles">Trier des listes (tri à bulles)</a></li>
            <li><a href="#eratosthene">Le Crible d'Ératosthène</a></li>
            <li><a href="#listNumber">Trier une liste de nombres</a></li>
          </ul>
        </nav>
      </article>
      <article>
        <h3 id="searchInUnordered">Position d'une valeur (liste non triée)</h3>
        <p>Dans le cas d'une liste non triée, il sera nécessaire de parcourir toutes les cases une à une.</p>
        <div class="code">
          <code>const temperatures = [12, 5, 29, -3]<br>
            const val = 5<br>
            for (let i = 0; i < temperatures.length; i++) {<br>
              if (val === temperatures[i]) {<br>
                console.log(i)<br>
              }<br>
            }</code>
        </div>
      </article>
      <article>
        <h3 id="maxInUnordered">Maximum d'une valeur (liste non triée)</h3>
        <p>L'algorithme suivant retourne la valeur maximale d'une liste non triée. Il teste les éléments un à un et possède une variable qui stocke le maximum.</p>
        <div class="code">
          <code>const temperatures = [12, 5, 29, -3]<br>
            let max = temperatures[0]<br>
            for (let i = 1; i < temperatures.length; i++) {<br>
              if (max < temperatures[i]) {<br>
                max = temperatures[i]<br>
              }<br>
            }<br>
            console.log(max)</code>
        </div>
        <p>La recherche du minimum est identique. Il suffira jsute d'inverser la condition du if à l'intérieur de la boucle.</p>
        <p>La complexité en temps de ces deux algorithmes est <b>O(<i>n</i>)</b> car il est nécessaire de parcourir tous les éléments de la liste pour trouver ce que l'on cherche.</p>
      </article>
      <article>
        <h3>Rechercher dans des listes triées</h3>
        <p>La complexité <b>O(<i>n</i>)</b> d'une recherche dans une liste non-triée n'est pas très optimale. Sur de grands volumes de données ou en cas de recherche fréquentes, le temps d'exécution ou les performances pourraient être impacté. Il est préférable de trier notre liste puis d'utiliser un algorithme de recherche pour liste triée.</p>
      </article>
      <article>
        <h3 id="maxInOrdered">Maximum d'une valeur (liste triée)</h3>
        <p>Il suffit d'une seule instruction pour trouver le maximum. La liste étant triée, il s'agit forcément du dernier élément. La complexité de l'algorithme est donc de <b>O(<i>1</i>)</b>.</p>
        <div class="code">
          <code>const sortedTemperatures = [-3, 5, 12, 29]<br>
            const max = sortedTemperatures[sortedTemperatures.length - 1]<br>
            console.log(max)</code>
        </div>
      </article>
      <article>
        <h3 id="naive">Algorythme naïf</h3>
        <p>Voici un algorithme qui permet de retourner les indices d'une valeur donnée dans une liste triée. Il est dit naïf car très intuitif mais pas des plus optimisé.</p>
        <div class="code">
          <code>const sortedTemperatures = [-3, 5, 12, 50, 50, 78, 94, 113, 129]<br>
            const val = 50<br>
            let i = 0<br>
            while (i < sortedTemperatures.length && sortedTemperatures[i] <= val) {<br>
              if (sortedTemperatures[i] === val) {<br>
                console.log(i)<br>
              }<br>
              i = i + 1<br>
            }<br>
            console.log('Fin')</code>
        </div>
      </article>
      <article>
        <h3 id="dichotomie">Recherche par dichotomie</h3>
        <p>Ce problème consiste à renvoyer la position d'une valeur donnée présente dans une liste triée. L'algorithme réalise une <strong><a href="#">dichotomie</a></strong> qui permet d'optimiser la recherche. On considère pour simplifier des listes sans doublons.<br>
          L'idée est la suivante :<br>
          <ul class="ul-p17">
            <li>la recherche se fait dans une fenêtre (la liste)</li>
            <li>la fenêtre initiale est divisée en deux</li>
            <li>si l'élément central est plus petit que la valeur, la fenêtre supérieure devient la nouvelle fenêtre de recherche</li>
            <li>sinon c'est la fenêtre inférieure qui le devient</li>
            <li>Une fois la nouvelle fenêtre définie, le processus recommence.</li>
          </ul>
          A chaque itération, la fenêtre de recherche est divisée par deux et l'algorithme converge très vite vers la bonne solution.</p>
          <div class="code"><code>const sortedTemperatures = [-3, 5, 12, 50, 78, 94, 113, 129]<br>
            const val = 12<br>
            let a = 0<br>
            let b = sortedTemperatures.length - 1<br>
            while (a <= b) {<br>
              const m = Math.floor((a + b) / 2)<br>
              if (sortedTemperatures[m] === val) {<br>
                console.log(m)<br>
                break<br>
              } else if (sortedTemperatures[m] < val) {<br>
                a = m + 1<br>
              } else {<br>
                b = m - 1<br>
              }<br>
            }
          </code></div>
          <h3>Déroulement pas à pas de la dichotomie</h3>
          <ul class="ul-p17">
            <li>Notre fenêtre est définie avec a = 0 et b = 7.</li>
            <li><b>Première itération:</b></li>
              <ul class="li-square ul-p17">
                <li>m prend la valeur 3 et sorted_temperatures[3]= 50.</li>
                <li>50 est supérieur à 12 donc la fenêtre inférieure est conservée, soit b = 2.</li>
              </ul>
            <li><b>Deuxième itération :</li></b>
              <ul class="li-square ul-p17">
                <li>m prend la valeur 1 et sorted_temperatures[1]= 5.</li>
                <li>5 est inférieur à 12 donc la fenêtre supérieure est conservée, c'est-à-dire a = 2.</li>
              </ul>
            <li><b>Troisième itération :</b></li>
            <ul class="li-square ul-p17">
              <li>m prend la valeur 2 et sorted_temperatures[2]= 12.</li>
              <li>La valeur a été trouvée, on affiche la position et on sort de la boucle.</li>
            </ul>
          </ul>
          La complexité en temps de la dichotomie <b>O(<i>log(n)</i>)</b> est bien meilleure notamment pour des très grandes listes.</p>
      </article>
      <article>
        <h3 id="cartesien">Créer des paires (produit cartésien)</h3>
        <p>Une des opérations résalisé dans le cadre du traitement d'une base de données est d'effectuer le produit cartésien. Cette opération mathématique permet de regrouper deux ensembles de données et de lister les combinaisons possibles entre eux. C'est une opération simple à réaliser, mais coûteuse en terme de complexité algorithmique.<br>Attention de ne pas lister les éléments d'un même ensemble.</p>
        <p>Pour réaliser cet algorithme il faut deux boucles imbriquées.</p>
        <div class="code">
          <code>const vehicles = ['Vélo', 'Trottinette', 'Roller']<br>
            const colors = ['Rouge', 'Bleu']<br>
            for (let i = 0; i < vehicles.length; i++){<br>
              for (let j = 0; j < colors.length; j++){<br>
                console.log(vehicles[i], colors[j])<br>
              }<br>
            }<br><br>
            //Affichage console :<br>
            Vélo Rouge<br>
            Vélo Bleu<br>
            Trottinette Rouge<br>
            Trottinette Bleu<br>
            Roller Rouge<br>
            Roller Bleu</code>
        </div>
        <p>La complexité du produit cartésien est <b>O(<i>n*m</i>)</b>. n est le nombre d'éléments de X et m celui de Y. Cette complexité est visible grâce à l’imbrication des boucles.</p>
      </article>
      <article>
        <h3 id="fibonacci">Suite de Fibonacci</h3>
        <p>Dans leur observation de la nature, certains mathématiciens ont découvert la récurrence d'une suite de nombres bien précise : la suite de Fibonacci. On retrouve, par exemple, cette suite dans la floraison de l'artichaut ou dans la disposition d'une pomme de pain. Cette présence énigmatique dans de nombreuses dispositions naturelles continuent d'intriguer les scientifiques et alimente encore aujourd'hui des recherches ou des créations artistiques.</p>
        <div class="code"><code>const n = Number(prompt('Entrer un entier supérieur à 1:'))<br>
          const fibo = new Array(n)<br>
          fibo[0] = 0<br>
          fibo[1] = 1<br>
          for (let i = 2; i < n; i++) {<br>
            fibo[i] = fibo[i - 1] + fibo[i - 2]<br>
          }<br>
          console.log(fibo)<br><br>
          //Affichage console :<br>
          [ 0, 1, 1, 2, 3 ]</code></div>
          <h3>Déroulement pas à pas de la suite de Fibonacci</h3>
          <ul class="ul-p17">
            <li>Pour n = 5.</li>
            <li>Une liste vide de taille 5 est créée.</li>
            <li>Les éléments 0 et 1 sont positionnés sur les deux premières positions.</li>
            <li>fibo = [0, 1, _, _, _].</li>
            <li>Ensuite, on entre dans la boucle.</li>
            <li><b>Première itération :</b></li>
              <ul class="li-square ul-p17">
                <li>i = 2 : fibo[2] = fibo[1] + fibo[0] = 1.<br>On a donc fibo = [0, 1, 1, _, _].</li>
              </ul>
            <li><b>Deuxième itération :</b></li>
              <ul class="li-square ul-p17">
                <li>i = 3 : fibo[3] = fibo[2] + fibo[1] = 2.<br>On a donc fibo = [0, 1, 1, 2, _].</li>
              </ul>
            <li><b>Troisième itération :</b></li>
              <ul class="li-square ul-p17">
                <li>i = 4 : fibo[4] = fibo[3] + fibo[2] = 3.<br>On a donc fibo = [0, 1, 1, 2, 3].</li>
              </ul>
            <li>i = n donc la boucle se termine.</li>
          </ul>
        <p>La liste des cinq premiers termes de la suite est affichée dans la console.</p>
        <p>La complexité en temps de cet algorithme est <b>O(<i>n</i>)</b>. On peut voir très clairement ce qui explique cette complexité car on voit deux boucles simples. On pourrait être plus précis en disant O(2 * n) mais cette complexité est considérée comme équivalente à O(n) car on souhaite simplement un ordre de grandeur.</p>
      </article>
      <article>
        <h3 id="triBulles">Trier des listes (tri à bulles)</h3>
        <p>L'idée de ce tri est de faire remonter itérations après itérations les valeurs hautes vers la fin de la liste à l'instar des gouttes d'huiles remontant petit à petit vers la surface de l'eau.</p>
        <div class="code"><code>const ages = [17, 1, 28, 5]<br>
          for (let i = ages.length - 1; i > 0; i--) {<br>
            for (let j = 0; j < i; j++) {<br>
              if (ages[j + 1] < ages[j]) {<br>
                const temp = ages[j + 1]<br>
                ages[j + 1] = ages[j]<br>
                ages[j] = temp<br>
              }<br>
            }<br>
          }<br>
          console.log(ages)</code></div>
        <h3>Déroulement pas à pas du tri à bulles</h3>
        <ul class="ul-p17">
          <li>Nous avons ages = [17, 1, 28, 5]</li>
          <li><b>Première itération :</b></li>
            <ul class="li-square ul-p17">
              <li>i = 3</li>
            </ul>
            <ul class="li-square ul-p17">
              <li><b>Première itération secondaire :</b></li>
                <ul class="li-square ul-p17">
                  <li>j = 0 : ages[0] (= 17) > ages[1] (= 1)<br>donc on échange les deux valeurs et la liste devient [1, 17, 28, 5].</li>
                </ul>
              <li><b>Deuxième itération secondaire :</b></li>
                <ul class="li-square ul-p17">
                  <li>j = 1 : ages[1] (= 17) < ages[2] (= 28)<br>donc la liste reste [1, 17, 28, 5].</li>
                </ul>
              <li><b>Troisième itération secondaire :</b></li>
                <ul class="li-square ul-p17">
                  <li>j = 2 : ages[2] (= 28) > ages[3] (= 5)<br>donc on échange les deux valeurs et la liste devient [1, 17, 5, 28].</li>
                  <li>j = 3 = i donc la boucle secondaire se termine.</li>
                </ul>
            </ul> 
          <li><b>Deuxième itération principale :</b></li>
            <ul class="li-square ul-p17">
              <li>i = 2</li>
              <li><b>Première itération secondaire :</b></li>
                <ul class="li-square ul-p17">
                  <li>j = 0 : ages[0] (= 1) < ages[1] (= 17)<br>donc la liste reste [1, 17, 5, 28].</li>
                </ul>
              <li><b>Deuxième itération secondaire :</b></li>
                <ul class="li-square ul-p17">
                  <li>j = 1 : ages[1] (= 17) > ages[2] (= 5)<br>donc on échange les deux valeurs et la liste devient [1, 5, 17, 28].</li>
                  <li>j = 2 = i<br>donc la boucle secondaire se termine.</li>
                </ul> 
            </ul> 
          <li><b>Troisième itération principale :</b></li>
            <ul class="li-square ul-p17">
              <li>i = 1</li>
              <li><b>Première itération secondaire :</b></li>
                <ul class="li-square ul-p17">
                  <li>j = 0 : ages[0] (= 1) < ages[1] (= 5)<br>donc la liste reste [1, 5, 17, 28].</li>
                  <li>j = 1 = i donc la boucle secondaire se termine.</li>
                </ul>
              </ul>
            <li>i = 0 donc la boucle principale se termine</li>
        </ul>
        <p>La complexité en temps de ce tri est <b>O(<i>n²</i>)</b>. On peut voir très clairement ce qui explique cette complexité grâce à la boucle imbriquée.</p>
      </article>
      <article>
        <h3 id="eratosthene">Le crible d'Erastosthène</h3>
        <p>Cet algorithme permet de trouver tous les nombres premiers inférieurs à un certain nombre. Un nombre premier est un nombre qui n'est divisible que par 1 et lui-même</p>
        <div class="code"><code>const limit = Number(prompt('Entrer la limite du crible'))<br>
          const L = []<br>
          for (let i = 2; i <= limit; i++) {<br>
            L.push(i)<br>
          }<br>
          const primeNumbers = []<br>
          while (L.length > 0) {<br>
            primeNumbers.push(L[0])<br>
            let i = 1<br>
            while (i < L.length) {<br>
              if (L[i] % L[0] === 0) {<br>
                L.splice(i, 1)<br>
              } else {<br>
                i++<br>
              }<br>
            }<br>
            L.splice(0, 1)<br>
          }<br>
          
          console.log(primeNumbers)<br><br>
          Affiche console :<br>
          [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]</code></div>
      </article>
      <article>
        <h3 id="listNumber">Trier une liste de nombres</h3>
        <p>Voilà de quelle manière une liste de nombres est triée avec sort() :</p>
        <div class="code"><code>const scores = [58, 13, 29, 100, 203, 1, 5, 13, 56, 33, 123];<br>
          console.log(scores.sort());<br><br>
          Affichage console :<br>
          [ 1, 100, 123, 13, 13, 203, 29, 33, 5, 56, 58 ]
        </code></div>
        <p>La fonction sort() n'est pas suffisante car elle trie les éléments de manière alphabétique. Pour cela, il faut une fonction supplémentaire :</p>
        <div class="code"><code>const scores = [58, 13, 29, 100, 203, 1, 5, 13, 56, 33, 123];<br>
          function compareNumbers(a, b) {<br>
             return a - b <br>
            }<br>
          console.log(scores.sort(compareNumbers))<br><br>
          Affichage console :<br>
          [1, 5, 13, 13, 29, 33, 56, 58, 100, 123, 203 ]
        </code></div>
      </article>
    </section>
    <p><a href="#up">Haut</a></p>
  </main>
  <footer>
    <p>&copy;2021 - Graduate développeur PHP/Symfony</p>
  </footer>
</body>
</html>